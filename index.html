<html>
	<head>
		<title>Micromachines</title>
		
		<script id="shader-vs" type="x-shader/x-vertex">
			#version 100
			precision mediump float;
			precision mediump int;

			struct Light {
				bool isActive;
				int type;
				vec4 position;
				vec4 direction;
				vec3 color;	
				float intensity;
				
				float constantAttenuation;
				float linearAttenuation;
				float quadraticAttenuation;
				
				float spotCosCutoff; 
				float spotExponent;
			};

			attribute vec4 inPosition;
			attribute vec3 inNormal; 
			attribute vec2 inTexCoord; 
			attribute vec4 inTangent;

			uniform mat4 m_pvm;
			uniform mat4 m_viewModel;
			uniform mat3 m_normal;

			
			varying	vec2 exTexCoord;
			varying	vec4 exPosition;
			varying	vec3 exNormal;
			varying	vec3 exEyeDirection;
			const int MaxLights = 9;
			varying vec3 exLights[MaxLights * 2];


			uniform Light lights[MaxLights];
			uniform vec4 shadowLight;
			uniform bool drawingShadows;


			void main (void) {

				
				exTexCoord = inTexCoord;
				exNormal = normalize(m_normal * inNormal);
				vec3 n = normalize(m_normal	* inNormal);	
				vec3 t = normalize(m_normal	* inTangent.xyz);	
				vec3 b = inTangent.w * cross(n, t);	


				vec3 pos = vec3(m_viewModel	* inPosition);	
				exPosition = m_viewModel	* inPosition;
				exEyeDirection = normalize(vec3(-pos));
									

				for (int i = 0; i < MaxLights * 2; i+=2) {
					Light light = lights[i/2];
					
					vec3 lightDir =	normalize(vec3(light.position) - pos);

					vec3 v;	
					v.x	= dot(lightDir, t);	
					v.y	= dot(lightDir, b);	
					v.z	= dot(lightDir, n);	
					vec3 lightVec =	normalize(v);

					vec3 halfVector	= normalize(lightDir - pos);
					v.x	= dot(halfVector, t);	
					v.y	= dot(halfVector, b);	
					v.z	= dot(halfVector, n);	
					vec3 halfVec	= normalize(v);	

					exLights[i] = lightVec;
					exLights[i+1] = halfVec;					
					

				}
				
				
				gl_Position = m_pvm * inPosition;	
				
				
			}

		</script>
		
		<script id="shader-fs" type="x-shader/x-fragment">
		    precision mediump float;
		    precision mediump int;

			varying	vec4 exPosition; 
			varying	vec3 exNormal;
			varying	vec3 exEyeDirection;
			varying	vec2 exTexCoord;

			struct Material {
				vec3 diffuse;
				vec3 ambient;
				vec3 specular;
				vec3 emissive;
				float shininess;
				float transparency;
				int texCount;
			};

			struct Light {
				bool isActive;
				int type;
				vec4 position;
				vec4 direction;
				vec3 color;	
				float intensity;
				
				float constantAttenuation;
				float linearAttenuation;
				float quadraticAttenuation;
				
				float spotCosCutoff; 
				float spotExponent;
			};

			// the set of lights to apply, per invocation of this shader
			const float density = 0.005;
			const float gradient = 1.3;
			const int MaxLights = 9;
			uniform Light lights[MaxLights];
			varying vec3 exLights[MaxLights * 2];
			uniform bool foggy;
			uniform bool useTextures;
			uniform int textureMode;
			uniform Material mat;
			uniform bool drawingShadows;

			uniform vec4 matDiffuse;

			uniform sampler2D woodDiffuse;
			uniform sampler2D woodSpecular;
			uniform sampler2D bambooDiffuse;
			uniform sampler2D bambooSpecular;
			uniform sampler2D mask;
			uniform sampler2D billboardTexture;

			uniform sampler2D woodNormal;
			uniform sampler2D bambooNormal;

			bool normalTexture = false;

			vec4 calcDirLight(Light light, vec3 lightDirection, vec3 halfVector, vec3 normal, vec3 materialDiffuse, vec3 materialSpecular) {

				
				float diff = max(0.0, dot(normal, lightDirection));
				
				vec3 HalfVector = normalize(halfVector);
				float spec = max(0.0, dot(normal, HalfVector));
				
				// surfaces facing away from the light (negative dot products)
				// won’t be lit by the directional light
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess); // sharpen the highlight
					
				vec3 diffuse = light.color * diff * materialDiffuse;
				vec3 specular = light.color * spec * materialSpecular;
				return vec4((diffuse + specular).xyz, 1.0);
			}
			vec4 calcDirLight2(Light light, vec3 normal, vec3 viewDir, vec3 materialDiffuse, vec3 materialSpecular) {
				vec4 lightDir4 = normalize(-light.direction);
				vec3 lightDir = vec3(lightDir4);
				float diff = max(0.0, dot(normal, lightDir));
				
				vec3 HalfVector = normalize(lightDir + viewDir);
				float spec = max(0.0, dot(normal, HalfVector));
				
				// surfaces facing away from the light (negative dot products)
				// won’t be lit by the directional light
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess); // sharpen the highlight
					
				vec3 diffuse = light.color * diff * materialDiffuse;
				vec3 specular = light.color * spec * materialSpecular;
				return vec4((diffuse + specular).xyz, 1.0);
			}
			float trash;
			vec4 calcPointLight(Light light, vec3 lightD, vec3 halfV, vec3 normal, vec3 materialDiffuse, vec3 materialSpecular) {

				
				vec3 lightDirection = lightD;
				float lightDistance = length(lightDirection);
				
				// normalize the light direction vector, so
				// that a dot products give cosines
				lightDirection = lightDirection / lightDistance;
				
				// model how much light is available for this fragment
				float attenuation = 1.0 / (light.constantAttenuation 
				+ light.linearAttenuation * lightDistance 
				+ light.quadraticAttenuation * lightDistance * lightDistance);
				
				// the direction of maximum highlight also changes per fragment
				vec3 halfVector = normalize(halfV);
				
				float diff = max(0.0, dot(normal, lightDirection));
				
			
				float spec = max(0.0, dot(normal, halfVector));
				trash = diff;
				
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess);

				trash = spec;
							
				vec3 diffuse = light.color * diff * materialDiffuse * attenuation;
				vec3 specular = light.color * spec * materialSpecular * attenuation;
				return vec4((diffuse + specular ).xyz, 1.0);

			}

			vec4 calcPointLight2(Light light, vec4 position, vec3 normal, vec3 viewDir, vec3 materialDiffuse, vec3 materialSpecular) {
				vec4 lightDirection4 = light.position - position;
				vec3 lightDirection = vec3(lightDirection4);
				float lightDistance = length(lightDirection);
				
				// normalize the light direction vector, so
				// that a dot products give cosines
				lightDirection = lightDirection / lightDistance;
				
				// model how much light is available for this fragment
				float attenuation = 1.0 / (light.constantAttenuation 
				+ light.linearAttenuation * lightDistance 
				+ light.quadraticAttenuation * lightDistance * lightDistance);
				
				// the direction of maximum highlight also changes per fragment
				vec3 halfVector = normalize(lightDirection + viewDir);
				
				float diff = max(0.0, dot(normal, lightDirection));
				float spec = max(0.0, dot(normal, halfVector));
				
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess);
							
				vec3 diffuse = light.color * diff * materialDiffuse * attenuation;
				vec3 specular = light.color * spec * materialSpecular * attenuation;
				return vec4((diffuse + specular ).xyz, 1.0);
			}

			vec4 calcSpotLight(Light light, vec3 lightD, vec3 halfV, vec3 normal, vec3 materialDiffuse, vec3 materialSpecular) {
				
				
				vec3 lightDirection = lightD;
				float lightDistance = length(lightDirection);
				lightDirection = lightDirection / lightDistance;
				
				float attenuation = 1.0 / (light.constantAttenuation 
				+ light.linearAttenuation * lightDistance 
				+ light.quadraticAttenuation * lightDistance * lightDistance);
				
				// how close are we to being in the spot?
				float spotCos = dot(lightDirection, (vec3(-light.direction)));
				// attenuate more, based on spot-relative position
				if (spotCos < light.spotCosCutoff)
					attenuation = 0.0;
				else
					attenuation *= pow(spotCos, light.spotExponent);
				
				vec3 halfVector = normalize(halfV);
				
				float diff = max(0.0, dot(normal, lightDirection));
				float spec = max(0.0, dot(normal, halfVector));
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess);
					
				vec3 diffuse = light.color * diff * materialDiffuse * attenuation;
				vec3 specular = light.color * spec * materialSpecular * attenuation;
				
				return vec4((diffuse + specular).xyz, 1.0);
			}
			vec4 calcSpotLight2(Light light, vec4 position, vec3 normal, vec3 viewDir, vec3 materialDiffuse, vec3 materialSpecular) {
				
				vec4 lightDirection4 = light.position - position;
				vec3 lightDirection = vec3(lightDirection4);
				float lightDistance = length(lightDirection);
				lightDirection = lightDirection / lightDistance;
				
				float attenuation = 1.0 / (light.constantAttenuation 
				+ light.linearAttenuation * lightDistance 
				+ light.quadraticAttenuation * lightDistance * lightDistance);
				
				// how close are we to being in the spot?
				float spotCos = dot(lightDirection, (vec3(-light.direction)));
				// attenuate more, based on spot-relative position
				if (spotCos < light.spotCosCutoff)
					attenuation = 0.0;
				else
					attenuation *= pow(spotCos, light.spotExponent);
				
				vec3 halfVector = normalize(lightDirection + viewDir);
				
				float diff = max(0.0, dot(normal, lightDirection));
				float spec = max(0.0, dot(normal, halfVector));
				if (diff == 0.0)
					spec = 0.0;
				else
					spec = pow(spec, mat.shininess);
					
				vec3 diffuse = light.color * diff * materialDiffuse * attenuation;
				vec3 specular = light.color * spec * materialSpecular * attenuation;
				
				return vec4((diffuse + specular).xyz, 1.0);
			}

			void main(void) {
				if(drawingShadows) {
					gl_FragColor = vec4(0,0,0,1);
					return;
				}
				vec4 outColor = vec4(0);
				
				vec3 materialDiffuse;
				vec3 materialSpecular;
				float materialTransparency;
				vec3 normal;
				vec3 normFromTex;
				
				if(useTextures) {
					if(textureMode == 0) {
						vec3 woodDiff = vec3(texture2D(woodDiffuse, exTexCoord * 15.0));
						vec3 bambooDiff = vec3(texture2D(bambooDiffuse, exTexCoord * 10.0));
						float mixCoefficient = (texture2D(mask, exTexCoord)).r;
						materialDiffuse = mix(woodDiff, bambooDiff, mixCoefficient);
						outColor += vec4(materialDiffuse * 0.1, 1);	
						
						vec3 woodSpec = vec3(texture2D(woodSpecular, exTexCoord * 15.0));
						vec3 bambooSpec = vec3(texture2D(bambooSpecular, exTexCoord * 10.0)) * 0.9;
						materialSpecular = mix(woodSpec, bambooSpec, mixCoefficient) ;
						materialTransparency = 1.0;

						vec3 woodNorm = 2.0 * vec3(texture2D(woodNormal, exTexCoord*15.0)) - 1.0;
						vec3 bambooNorm = 2.0 * vec3(texture2D(bambooNormal, exTexCoord*10.0)) - 1.0;
						normFromTex = mix(woodNorm, bambooNorm, mixCoefficient);
						normalTexture = true;
					}
					else if (textureMode == 1) {
						vec4 color = texture2D(billboardTexture, exTexCoord);
						materialDiffuse = vec3(color);
						outColor += vec4(materialDiffuse * 0.1, 1);
						materialSpecular = vec3(0.4, 0.6, 0.4);
						materialTransparency = color.w;
						normalTexture = false;
					}
					else if (textureMode == 2) {
						vec4 color = texture2D(billboardTexture, exTexCoord);
						materialDiffuse = vec3(color);
						outColor += vec4(materialDiffuse * 0.1, 1);
						materialSpecular = vec3(0.05, 0.05, 0.05);
						materialTransparency = color.w;
						normalTexture = false;
					}
					else if(textureMode == 3) {
						vec4 color = texture2D(billboardTexture, exTexCoord);	
						gl_FragColor = vec4(color.xyz, 0.7);
						return;
					}
					else if (textureMode == 4) {
						vec4 color = texture2D(billboardTexture, exTexCoord);	
						gl_FragColor = color * matDiffuse;
						return;
					}
					else if (textureMode == 5) {
						vec4 color = texture2D(billboardTexture, exTexCoord);	
						gl_FragColor = color;
						return;
					}	
				}	
				else {
					outColor += vec4(mat.ambient.xyz, 1);	
					materialDiffuse = mat.diffuse.xyz;
					materialSpecular = mat.specular.xyz;
					materialTransparency = mat.transparency;
					normalTexture = false;
				}
				
				if (useTextures && textureMode == 0){
					normal = normalize(normFromTex);
				}
				else{
					normal = normalize(exNormal);
				}
				
				for (int i = 0; i < MaxLights*2; i+=2) {
					Light light = lights[i/2];
					if(light.isActive) {	

						vec3 lD = exLights[i];
						vec3 hV = exLights[i + 1];
						
						if (light.type == 1) {
							if(normalTexture) {
								outColor += calcPointLight(light, lD, hV, normal, materialDiffuse, materialSpecular) *  0.5;
							}
							else {
								outColor += calcPointLight2(light, exPosition, normal, exEyeDirection, materialDiffuse, materialSpecular) *  0.5;
							}
						}
						else if (light.type == 2) {
							if (normalTexture) {
								outColor += calcSpotLight(light,lD, hV, normal, materialDiffuse, materialSpecular) *  0.5;
							}
							else {
								outColor += calcSpotLight2(light, exPosition, normal, exEyeDirection, materialDiffuse, materialSpecular) * 0.5;
							}
							
						}
						else if(light.type == 0)	{
							if(normalTexture) {
								outColor += calcDirLight(light,lD, hV, normal, materialDiffuse, materialSpecular)
							 	* 0.5;
							}
							else {
								outColor += calcDirLight2(light, normal, exEyeDirection, materialDiffuse, materialSpecular) * 0.5;
								 
							}
						}
						
					}
				}
				
				outColor.w = materialTransparency;
				if (outColor.w == 0.0)
					discard;
				
				if(foggy){
					float distance = length(exPosition);

					float fogAmount = exp(-pow((distance*density), gradient));
					//float fogAmount = exp(-distance * 0.005);
					fogAmount = clamp(fogAmount, 0.0 ,1.0);
		
					outColor = mix(vec4(0.5,0.5,0.5,1.0), outColor , fogAmount);
	            }
				gl_FragColor = outColor;
				//gl_FragColor = vec4(normal, 1.0);
				//gl_FragColor = vec4(trash, 0, 0, 1);
				return;
			}
		</script>

		


		<script type="text/javascript" src="js/libs/gl-matrix-min.js"></script>
		<script type="text/javascript" src="js/libs/webgl-utils.js"></script>

		<script type="text/javascript" src="js/objects/resources/objs_data.js"></script>
		<script type="text/javascript" src="js/objects/resources/objs_data2.js"></script>
		<script type="text/javascript" src="js/objects/resources/track_data.js"></script>		
		<script type="text/javascript" src="js/math.js"></script>
		<script type="text/javascript" src="js/shader.js"></script>
		<script type="text/javascript" src="js/cameras.js"></script>
		<script type="text/javascript" src="js/ObjModel.js"></script>
		<script type="text/javascript" src="js/animation.js"></script>
		<script type="text/javascript" src="js/gm.js"></script>
		<script type="text/javascript" src="js/lights/lights.js"></script>
		<script type="text/javascript" src="js/objects/car.js"></script>
		<script type="text/javascript" src="js/objects/lamp.js"></script>
		<script type="text/javascript" src="js/objects/border.js"></script>
		<script type="text/javascript" src="js/objects/track.js"></script>
		<script type="text/javascript" src="js/objects/butter.js"></script>
		<script type="text/javascript" src="js/objects/cheerio.js"></script>
		<script type="text/javascript" src="js/objects/orange.js"></script>
		<script type="text/javascript" src="js/objects/billboard.js"></script>
		<script type="text/javascript" src="js/objects/finishLine.js"></script>
		<script type="text/javascript" src="js/objects/particleSystem.js"></script>
		<script type="text/javascript" src="js/objects/particle.js"></script>
		<script type="text/javascript" src="js/objects/sun.js"></script>
		<script type="text/javascript" src="js/objects/lensFlare.js"></script>
		<script type="text/javascript" src="js/script.js"></script>
		<style type="text/css">
		    #loadingtext {
		        position:absolute;
		        top:250px;
		        left:150px;
		        font-size:2em;
		        color: white;
		    }
		    html, body {
		        margin: 0px;
		        width: 100%;
		        height: 100%;
		        overflow: hidden;
		    }
			canvas {
				width: 100%;
		        height: 100%;
				
			}
			#micromachines-canvas {
				position: absolute;
			  	left: 0px;
			  	top: 0px;
			}
			#text-canvas {
			  position: absolute;
			  left: 0px;
			  top: 0px;
			  z-index: 2;
			}
		</style>
	</head>
	<body onload="webGLStart();">
		<canvas id="text-canvas"></canvas>
		<canvas id="micromachines-canvas"></canvas>
		<div id="loadingtext">Loading world...</div>
	</body>
</html>